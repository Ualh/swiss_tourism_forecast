---
title: Zurich and Vaud by the Numbers - Predictive Insights into Tourism Dynamic
author:
 - Valeriia Bilousko, Urs Hurni, Jayesh Smith
 - Anastasia Pushkarev, Emeline Raimon
institute : University of Lausanne
date: today
title-block-banner: "#0095C8" #chosen for the university of lausanne
format:
  html:
    toc: true
    toc_float: true
    code-fold: true
    number-sections: true
    html-math-method: katex
    self-contained: true
    code-summary: "Click to show code"
    # pdf: default # use this if you want to render pdfs instead
abstract: |
  The following Forecasting project focuses on ...
---

```{r loading libraries, echo = FALSE, message = FALSE, warning = FALSE, include=FALSE}
# loading all the necessary packages
library(here)
source(here("docs/setup.R"))
#library(anomalize)
```

# Exploration & Visualization

## Objectives

The main objectives of this project is to predict :

-   The overnight stays of the visitors in Vaud, from October 2023 until December 2024.

-   The overnight stays of visitors from Philippines to Z체rich, from October 2023 until December 2024.

# Data

## Cleaning & Wrangling

Here we load the data and clean it. We will focus on the data for Vaud and Zurich, as well as the data for the Philippines. 

```{r}
# Load the data in folder data named Dataset_tourism.xlsx)
tourism_data <- readxl::read_xlsx(here("data/Dataset_tourism.xlsx"))

#removing value 'Herkunftsland - Total' in column 'Herkunftsland' as it is just the total
#tourism_data <- tourism_data %>% filter(Herkunftsland != "Herkunftsland - Total")
#print unique values in month column
unique(tourism_data$Monat)
# change ' [1] "Januar"    "Februar"   "M채rz"      "April"     "Mai"       "Juni"      "Juli"      "August" "September" "Oktober"   "November"  "Dezember" into english month'
tourism_data$Monat <- tourism_data$Monat %>% recode_factor(
  "Januar" = "January",
  "Februar" = "February",
  "M채rz" = "March",
  "April" = "April",
  "Mai" = "May",
  "Juni" = "June",
  "Juli" = "July",
  "August" = "August",
  "September" = "September",
  "Oktober" = "October",
  "November" = "November",
  "Dezember" = "December"
)
#add date type column for plotting purposes
tourism_data <- tourism_data %>% mutate(Date = dmy(paste("01", Monat, Jahr)))
# filtering out 'Herkunftsland - Total' in column 'Herkunftsland' as it is just the total
tourism_data_no_total <- tourism_data %>% filter(Herkunftsland != "Herkunftsland - Total")
#check for NAN
sum(is.na(tourism_data_no_total))
#analyse the NAN values, where are they
(tourism_data_no_total %>% filter(is.na(value)))
```

### Tourism Data - General Overview

The dataset contains information about the overnights stays by tourists in the various Swiss cantons. It indicates the tourist's country of origin, the canton of stay, the month, the year and the total number of overnights stays.

*Check the appendix for more details on the table and cleaning process*.

### Tourism Data - Vaud

Given the two objectives of the project, we are going to filter the initial dataset in order to keep and analyse only the cantons of interest. We start by filtering the "Kanton" column to keep only the canton of Vaud.

Here are the first 1000 instances of the raw data :

```{r}
# Filter by canton Vaud 
tourism_vaud <- tourism_data %>% filter(Kanton == "Vaud")
#check for NAN
sum(is.na(tourism_vaud))
#show the data in a table using reactable
reactable(head(tourism_vaud, 1000), 
          searchable = TRUE,
          defaultPageSize = 5,
          sortable = TRUE,
          filterable = TRUE,
          pagination = TRUE,
          bordered = TRUE,
          highlight = TRUE,
          striped = TRUE,
          compact = TRUE,
          showPageSizeOptions = TRUE,
          showSortable = TRUE
          )
```

Note that no missing values were found in the dataset.

### Tourism Data - Zurich and Philippines

The data Zurich contained the total number of overnight stays in Zurich by tourists from different countries. We are interested in the number of overnight stays by tourists from the Philippines. *See appendix for more details on the table.*

Thus, we are filtering the "Kanton" column and the 'Herkunftsland' column, keeping "Zurich" and "Philippinen" for the country of origin.

Here is all the instances of the raw filtered data :

```{r Tourism Zurich and Philippines}
#filter column 'Kanton' for Zurich
tourism_data_zurich <- tourism_data_no_total %>% filter(Kanton == "Z체rich")
#check for NAN
sum(is.na(tourism_data_zurich))
#analyse the NAN values, where are they
tourism_data_zurich %>% filter(is.na(value))

tourism_data_zurich_philippines <- tourism_data_zurich %>% filter(Herkunftsland == "Philippinen")
#show table using reactable
reactable(tourism_data_zurich_philippines, 
          searchable = TRUE,
          defaultPageSize = 5,
          sortable = TRUE,
          filterable = TRUE,
          pagination = TRUE,
          bordered = TRUE,
          highlight = TRUE,
          striped = TRUE,
          compact = TRUE,
          showPageSizeOptions = TRUE,
          showSortable = TRUE
          )
```

Filtering for `Philippinen` solved the problem of missing data we had with all countries of origin. The overnight stays are all included throughout the period.

# EDA - Vaud

## International Visitors in Vaud

The graph shows the monthly number of overnight stays in Vaud from tourists of different countries. The period runs from January 2005 to September 2023.

```{r vaud all}
# Create the ggplot object
plot_vaud <- tourism_vaud %>% 
  filter(Herkunftsland != 'Herkunftsland - Total') %>%
  ggplot(aes(x = Date, y = value, group = Herkunftsland, color = Herkunftsland,
             text = paste("Country:", Herkunftsland, "Trips:", value))) +  # Added text for tooltip
  geom_line(show.legend = FALSE) + 
  scale_color_viridis_d() +  # Use viridis color palette
  labs(title = "Number of visitors from Each Country to Vaud",
       x = "Date",
       y = "Number of Trips") +
  theme_minimal()

# Convert to an interactive plotly object with specified width and height
interactive_plot <- ggplotly(plot_vaud, tooltip = "text", width = 600, height = 400)


# Adjust plotly settings 
interactive_plot <- interactive_plot %>%
  layout(
    margin = list(l = 60, r = 60, b = 60, t = 80),
    showlegend = FALSE # Remove legend
  )

# Display the interactive plot
interactive_plot
```

The time plot reveals some interesting features. - According to the graph, tourists come mainly from Switzerland. The second visitor country is France. - There are large dips in the number of overnight stays at the beginning of each year -- these are due to holiday effects. - There was an important drop during the period in 2020 -- this was due to the COVID pandemic. - For swiss tourists, there is visible increasing trend before and after the pandemic.

This time plot takes the total number of tourists in the canton of Vaud, combining all countries of origin. Here, we can better observe the seasonal pattern in the data. The number of tourists decreases at the end and beginning of each year and increases in the middle of the year during the summer holidays. There is also an *increasing* trend pattern if we do not take into account the period of the pandemic in 2020 which caused an important drop in travel and therefore tourism in Vaud. We'll come back to this outlier later. Any forecasts of this series would need to capture the seasonal pattern, and the fact that the trend is changing over the period.

Graphical view of total number of tourists in canton Vaud :

```{r vaud aggregated}
tourism_vaud_total <- tourism_vaud %>%
  filter(Herkunftsland == 'Herkunftsland - Total') %>%
  select(-c(Herkunftsland, Kanton, Monat, Jahr))

# Create the ggplot object with viridis color palette
plot_vaud_total <- tourism_vaud_total %>%
  ggplot(aes(x = Date, y = value)) +
  geom_line(color = viridis(1)) +  # Use viridis color palette for a single line
  labs(x = "Date", y = "Number of tourists", title = "Total number of tourists in canton Vaud") + 
  theme_minimal()

# Convert to an interactive plotly object with specified width and height
interactive_plot_total <- ggplotly(plot_vaud_total, width = 600, height = 400)

# Adjust plotly settings
interactive_plot_total <- interactive_plot_total %>%
  layout(
    margin = list(l = 60, r = 60, b = 60, t = 80),
    showlegend = FALSE  # Remove legend if any
  )

# Display the interactive plot
interactive_plot_total
```

### Decomposition

We have process an additive decomposition of the time series into three components: *trend, seasonality and residual*. These components will allow us to understand how they contribute to the variations observed in Swiss tourism data.

```{r decomposition}
# Convert data to a time series object
vaud_ts <- tourism_vaud_total %>%
  arrange(Date) %>%
   # Filtre pour enlever les valeurs NA dans 'Date'
  filter(!is.na(Date)) %>%
  # Ensure data is complete and monthly
  complete(Date = seq.Date(min(Date, na.rm = TRUE), max(Date, na.rm = TRUE), by = "month")) %>%
  replace_na(list(value = 0)) %>%  # Replace NA values if there are any
  # Create a time series object
  with(ts(value, frequency = 12, start = decimal_date(min(Date, na.rm = TRUE))))

# Perform STL decomposition
 stl(vaud_ts, s.window = "periodic") %>% 
   autoplot() +
  labs(x = "Date", y = "Number of tourists", title = "STL Decomposition for number of tourists in canton Vaud") +
  theme_minimal()
```

The main insights from this decomposition reflect what we have already observed.

-    A clear upward trend until around 2020, when it peaks before falling sharply as a result of the pandemic and travel restrictions.

-   Monthly seasonality, with clear and regular fluctuations due to seasonal factors.

-   A stable residual component until 2020. After this period, there is a slight increase in volatility which may indicate that other events are having an impact on this time series which are not captured by the first two components.

# EDA - Zurich

As for Vaud, the most frequent visitors to Zurich are Swiss. Germany and United States are the two main foreign countries to visit Zurich. This can be explained by the fact that the canton of Zurich is closer to Germany and therefore easier to reach. The same applies to France with the canton of Vaud. The yellow curve represents the Philippines. The curve is flat and shows a considerably small number of trips from this country over the period. There is a drastic fall in 2020 caused by COVID-19. The pandemic has had a significant impact on the tourism industry worldwide. At first glance, there are regular seasonal peaks for most countries which also suggest the presence of seasonality in tourism in the canton of Zurich. *check the Appendix for more details with a Overall Zurichs Visitors graph*

## Zurich and Philippines Visitors

This graph shows only visitors from the Philippines, as this is the country of interest in our analysis.

```{r}
# Use tourism_data_zurich_philippines data to plot the values in y axis and Date in x axis
p <- ggplot(tourism_data_zurich_philippines, aes(x = Date, y = value)) +
  geom_line(color = viridis(1)) +  # Use viridis color palette for a single line
  labs(title = "Number of Trips from Philippines to Zurich",
       x = "Date",
       y = "Number of Trips") +
  theme_minimal()

# Convert to an interactive plotly object with specified width and height
interactive_plot <- ggplotly(p, width = 600, height = 400)

# Adjust plotly settings
interactive_plot <- interactive_plot %>%
  layout(
    showlegend = FALSE  # Remove legend if any
  )

# Display the interactive plot
interactive_plot
```

### Pattern

We choose a multiplicative model for the STL decomposition of the number of trips from the Philippines to Zurich because the data (previous plot) shows increasing variance and larger fluctuations as the number of trips grows, suggesting that seasonal and trend components scale proportionally with the overall level of the series. *check the appendix for the additive decomposition and further seasonal graph*

#### Decomposition

```{r}
# Convert data to a time series object
tourism_ts <- tourism_data_zurich_philippines %>%
  arrange(Date) %>%
  # Ensure data is complete and monthly
  complete(Date = seq.Date(min(Date), max(Date), by = "month")) %>%
  replace_na(list(value = 0)) %>%  # Replace NA values if there are any
  # Create a time series object
  with(ts(log(value), frequency = 12, start = decimal_date(min(Date))))

# Perform STL decomposition on the transformed data
tourism_stl <- stl(tourism_ts, s.window = "periodic")

# Plotting the results (transforming back by exponentiating)
autoplot(tourism_stl) +
  labs(x = "Date", y = "Number of tourists", title = "Multiplicative STL Decomposition for number of tourists from Philippines to Zurich") +
  theme_minimal()

```

-   An upward trend until around 2020, when it falls sharply because of the pandemic and travel restrictions. The pandemic had a longer effect on the Philippine tourism, which stopped for a longer period (around 2 years or more).
-   Multiple peaks in the seasonal monthly component. These fluctuations are due to their calendar. Philippines start their summer holidays earlier than we do (31 of May - 29 of July) and have longer La Toussaint holidays (5 October - 18 October - 28 October).
-   A residual component with moderate variability which increases from 2020 onwards, indicating the influence of unforeseen or exceptional events (such as the pandemic) that have disrupted the usual models.

#### Seasonality

```{r}
# several chart per month to see the seasonality
ggsubseriesplot(tourism_ts) + ylab("Number of tourists") + xlab("Month") + ggtitle("Seasonal subseries plot")

#debug
#better to use gg_subseries to see the seasonality
#tourism_ts %>% gg_subseries(value) + ylab("Number of tourists") + xlab("Month") + ggtitle("Seasonal subseries plot")
```

The months of May to July and October seem to have visitor peaks, which may indicate a high tourist season during this period. As we saw before, this is due to their calendar. The years 2022 and 2023 show a significant increase in visitor numbers compared with previous years. In particular, the months from May to October 2022 and 2023 show much higher values. This growth may be due to several factors, such as a post-pandemic recovery in travel or specific initiatives that have attracted more tourists.


#### Trend

There is an upward trend until around 2020, when it falls sharply because of the pandemic and travel restrictions. The pandemic had a longer effect on the Philippine tourism, which stopped for a longer period (around 2 years or more).

# Modelling

This part is about building on your knowledge of time series techniques to model your data. You can investigate various models but you should justify in your report your choices regarding these. Pay attention to the conditions that are needed to apply a specific model. Treat also carefully seasonality, outliers, collinearity, covariates, special events, etc. Remember the following steps:

(a) Aggregation choice for hierarchical time series
(b) Model building
(c) Model selection

## Total number of visitors in Vaud

In this section we will focus on the total number of visitors in Vaud. We will use the ETS and ARIMA models to forecast the number of visitors in Vaud over a 15-month horizon.

### ETS

The ETS (Error, Trend, Seasonality) forecast model presents numerous advantages in predicting the number of visitors to canton Vaud over a 15-month horizon due to its ease of implementation and reliability of results. The model is based on using trend and seasonality of past data to predict future without request of extra features.

```{r}
ets_vaud <- ets(vaud_ts, model = "AAA")
forecast_ets_vaud <- forecast(ets_vaud, h = 24) %>% plot(main = "Forecast of visitors in Vaud", xlab = "Date", ylab = "Number of visitors")
```

Employing the ETS "AAA" model, characterized by additive consideration of error, trend, and seasonality components, we forecast number of visitors in canton Vaud for 15 months. The forecast generated by the ETS model appears reasonable, it follows trend and seasonality; however, the wide range of the confidence interval indicates a high level of uncertainty surrounding the predictions.

### ARIMA

The automatic ARIMA (AutoRegressive Integrated Moving Average) model offers a data-driven approach to predict future trends. By automatically selecting the optimal parameters for the ARIMA model, including the order of autoregressive, differencing, and moving average components, this method simplifies the forecasting process while still capturing the underlying patterns in the data. Leveraging historical data, the automatic ARIMA model generates forecasts that account for both trend and seasonality.

```{r}
# Convert your time series data to a tsibble object
vaud_tsibble <- as_tsibble(vaud_ts)

# Fit ARIMA model to the data
fit_vaud <- vaud_tsibble %>%
  model(auto_arima = ARIMA(value, stepwise = FALSE, approximation = FALSE))

# Generate forecasts for the next 2 years (24 months)
forecast_vaud <- fit_vaud %>%
  forecast(h = 15)

# Plot the forecast
forecast_vaud %>%
  autoplot(data = vaud_tsibble, main = "ARIMA Forecast for Vaud Tourism", ylab = "Number of Tourists")

#Provide forecast in table
as.data.frame(forecast_vaud) %>% kable(caption = "Forecast for Vaud Tourism") %>%
  kable_styling(full_width = FALSE)
```

Automatically the model ARIMA(5,0,0)(0,1,1) was chosen. The graph shows that the seasonality observed in the historical data continues to manifest itself in the future forecasts, with recurring seasonal peaks and troughs. This demonstrates the robustness of the ARIMA model Forecasts for the next two years (15 months) are represented by the blue line. The violet bands around the blue line represent the forecast confidence interval, indicating the range of values within which future values are likely to lie with a certain probability. Due to the drop observed in 2020, the trend is showing a slight downward trajectory, however, currently, there are no evident reasons for a decrease in the number of visitors.

To capture the positive trend we use model ARIMA (5,1,0)(0,1,1). Changing models explicitly using a differencing order of 1 in the non-seasonal component provide better flexibility in capturing any underlying trend patterns in the data. This adjustment allows the model to more effectively account for changes in the level of the time series data over time, potentially leading to improved accuracy in forecasting future trends in tourist arrivals in Canton Vaud.

```{r}
# Fit ARIMA model with specified parameters
arima_model <- arima(vaud_ts, order = c(5, 1, 0), seasonal = list(order = c(0, 1, 1), period = 12))

forecast_a_vaud <- arima_model %>%
  forecast(h = 15)

# Plot the forecast
forecast_a_vaud %>%
  autoplot(data = vaud_tsibble, main = "ARIMA Forecast for Vaud Tourism", ylab = "Number of Tourists")

#Provide forecast in table
as.data.frame(forecast_a_vaud) %>% kable(caption = "Forecast for Vaud Tourism") %>%
  kable_styling(full_width = FALSE)
```

The ARIMA(5,1,0)(0,1,1) model effectively captures both the positive trend and seasonality present in the data, resulting in a realistic forecasting scenario. The approach results in forecasts that closely align with observed patterns, leading to a narrow confidence interval enhancing the reliability of predictions for tourist arrivals in canton Vaud.

## Zurich and Philippines

In this section, we will focus on the number of visitors from the Philippines to Zurich. We will use the Naive as a benchmark for ETS and ARIMA models to forecast the number of visitors from the Philippines to Zurich over a 15-month horizon.

### Forecast without dealing with Covid

As we have seen, Covid has had a significant impact on the number of tourists in Zurich. We will first forecast the number of tourists without taking into account the Covid period. This will allow us to see the impact of the pandemic on the forecasts.

#### Naive Forecast

The graph shows the historical trend in the number of tourists from the Philippines to Zurich and the forecasts for the next 15 months using the naive model. We took the graph representing the total number of tourists coming from the Philippines to Zurich.

```{r}
#convert tourism_ts to tsibble
tourism_ts <- tourism_ts %>% as_tsibble()
# Fit a naive model
fit <- tourism_ts %>%
  model(NAIVE = NAIVE(value))
# Forecast the next 2 years periods
forecast <- fit %>%
  forecast(h = 15)
# Plot the forecasts along with the historical data, and make the colors of the forecast a bit more transparent for distinguishably purposes
plot <- forecast %>%
  autoplot(tourism_ts, alpha = 0.5) +
  labs(title = "Forecast of tourists from Philippines to Zurich",
       x = "Date",
       y = "Number of tourists") + guides(colour = guide_legend(title = "Forecast"))
plot
```

This naive model predicts that future values will be equal to the last observed value in the time series. It does not take into account the past events like the pandemic and assumes here that the levels observed after this extreme fall will remain unchanged. The model does not take into account trends or seasonality neither, which are very present in our case. It's a simplified approach.

The blue areas represent the 80% (darker) and 95% (lighter) confidence intervals of the forecasts. The wider the interval, the greater the uncertainty about the long-term forecasts which is the case here.

We can see here the metrics of the naive model :
```{r}
metrics_naive <- fit %>% accuracy()
# Display accuracy metrics in an HTML table
metrics_naive <- metrics_naive %>%
  kable("html", caption = "Naive Model Metrics") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

#### ETS

```{r warning=FALSE}
# Fit an ETS model
# Adjusting the model parameters according to the characteristics of the data
# Here "A" means additive error, "N" means no trend, and "N" means no seasonality
# change these if needed
fit <- tourism_ts %>%
  model(ETS_M_seaso = ETS(value ~ error("A") + trend("A") + season("A"))) #multiplicative seasonality)
# Forecast the next 2 years periods
forecast <- fit %>%
  forecast(h = 15)
# Plot the forecasts along with the historical data, and make the colors of the forecast a bit more transparent for distinguishably purposes
plot <- forecast %>%
  autoplot(tourism_ts, alpha = 0.5) +
  labs(title = "Forecast of tourists from Philippines to Zurich",
       x = "Date",
       y = "Number of tourists") + guides(colour = guide_legend(title = "Forecast"))
plot
```

Clearly see here that the confidence interval is too big, almost like a naive forecast, therefore as suspected we will move to a *multiplicative* seasonality model.

We see here the metrics of the ETS AAA model :
```{r}
# Calculate the accuracy of the training set
metrics_ets_AAA <- fit %>% accuracy()

# Display accuracy metrics in an HTML table
metrics_ets_AAA %>%
  kable("html", caption = "ETS AAA Metrics") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

Why trend dp and seaso M ? - Trend is present so A - Seasonality is present and growing over time so Multiplicative was chosen

```{r}
# comparing several model
fit <- tourism_ts %>%
  model(
        ETS_M_seaso = ETS(value ~ error("A") + trend("A") + season("M")), #multiplicative seasonality
        ETS_M_seaso_Ad = ETS(value ~ error("A") + trend("Ad") + season("M")), #dampted trend
  )

# Forecast the next 2 years periods
forecast <- fit %>%
  forecast(h = 15)

# Extract the forecast for ETS_M_seaso_Ad
forecast_ETS_M_seaso_Ad <- forecast %>%
  filter(.model == "ETS_M_seaso_Ad") %>%
  as.data.frame()
# Plot the forecasts along with the historical data, and make the colors of the forecast a bit more transparent for distinguishably purposes
plot <- forecast %>%
  autoplot(tourism_ts, level = 90, color = "blue", alpha = 0.5) +
  labs(title = "Forecast of tourists from Philippines to Zurich",
       x = "Date",
       y = "Number of tourists") + guides(colour = guide_legend(title = "Forecast"))
plot
```

We can see here the metrics of the two ETS models (AAM and AAdM) :
```{r}
# Extract AIC values
aic_values <- fit %>%
  glance() %>%
  select(.model, AIC)

# Print the AIC values
print(aic_values)

# Display AIC values with forecast metrics
metrics <- fit %>% accuracy()
metrics_with_aic <- metrics %>%
  left_join(aic_values, by = ".model")

# Display metrics with AIC in an HTML table
metrics_ets <- metrics_with_aic %>%
  kable("html", caption = "Model Accuracy Metrics with AIC Values") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

metrics_ets
```

We observe that the damped model is better on almost all metrics.

#### ARIMA

We fit 3 different models

- one with auto-arima
- Anoter one with auto-arima but with seasonality added
- And one with auto-arima but with stepwise and approximation options turned off for a more thorough search.

NOTE A REFORMULER PLUS PETIT
Reasons to Turn Off Stepwise and Approximation
Accuracy Over Speed: If computational resources and time are not a constraint, turning off these options can lead to more accurate and reliable model selection and parameter estimation.
Better Model Selection: An exhaustive search (with stepwise = FALSE) and exact estimation (with approximation = FALSE) increase the chances of identifying the true underlying model, which can improve forecast accuracy.
Complex Data: For datasets with complex patterns or when high accuracy is critical, the benefits of thorough model exploration and exact estimation outweigh the increased computational cost.
```{r}
# Fit an automatic ARIMA model
fit_arima <- tourism_ts %>%
  model(ARIMA_auto = ARIMA(value),
        ARIMA_auto_seasonal = ARIMA(value~season()),
        ARIMA_auto_stepwise = ARIMA(value, stepwise = FALSE, approximation = FALSE))

# Forecast the next 15 months
forecast_arima <- fit_arima %>%
  forecast(h = 15)

# Plot the forecasts along with the historical data
plot_arima <- forecast_arima %>%
  autoplot(tourism_ts, alpha = 0.3) +
  labs(title = "ARIMA Forecast of Tourists from the Philippines to Zurich",
       x = "Date",
       y = "Number of Tourists") +
  guides(colour = guide_legend(title = "Forecast"))
plot_arima
```

We see that that the Auto-ARIMA with seasonality is more negative than the two others and that the stepwise and approximation options turned off is more positive. The auto-arima alone is in between both.

Here are the metrics of the ARIMA model :
```{r}
# Extract AIC values
aic_values <- fit_arima %>%
  glance() %>%
  select(.model, AIC)

# Calculate the accuracy of the training set
metrics_arima <- fit_arima %>% accuracy()

# Combine accuracy metrics with AIC values
metrics_arima <- metrics_arima %>%
  left_join(aic_values, by = ".model")

# Display accuracy metrics with AIC values in an HTML table
metrics_arima_table <- metrics_arima %>%
  kable("html", caption = "Model Accuracy Metrics with AIC Values") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))

metrics_arima_table
```

We observe with the metrics that the more complex model is the best by almost metrics but followed very closely by the auto-arima with seasonality model. The lowest AIC for the more complex model is a good sign that it is the best model.

### Forecasting Amidst the Covid-19 Pandemic

Now after those forecast we will take into account the Covid period and see if it will provide a better forecast.

#### How Philippines dealt with it

In 2021, the Philippines faced the challenges of the COVID-19 pandemic with a mix of resilience and adaptation.

CHANGE THIS TEXT ITS BULLSHIT \*\*\*\*\* - Lockdowns and Waves: The country experienced two waves of COVID-19, leading to prolonged lockdowns throughout the year. These restrictions aimed to curb the spread of the virus. - Vaccination Campaign: Despite challenges, millions of Filipinos received COVID-19 vaccines. However, experts raised concerns about the campaign's sluggish pace. - Senate Investigations: Lawmakers probed alleged anomalies in pandemic contracts, leading to marathon Senate hearings. - Easing Restrictions: Towards the end of the year, daily cases dropped, and mandatory face shield policies were lifted. This signaled progress in overcoming the crisis. - Risk-Based Decisions: While the holidays looked promising, the threat of new variants remained. Experts advised practicing "risk-based" decisions for activities despite low case numbers1. - Filipinos have become more mindful of hygiene practices, including social distancing, mask-wearing, and proper handwashing. The pandemic also prompted a shift in consumption patterns, with increased focus on essentials and at-home entertainment. However, air travel remains limited due to ongoing concerns.

As for travel, the Philippines continues to navigate the balance between safety and economic recovery. While some travel restrictions have eased, travellers must stay informed about evolving guidelines and exercise caution when planning trips. The threat of new variants underscores the need for vigilance and informed decision-making1 \*\*\*\*\*\*

Question : How to deal with this blackswan event ?

#### Covariates

TEXT A PAUFINER Covariate Adjustment Adjust your forecasts to account for the impact of COVID-19 by including covariates that capture the effects of the pandemic. These covariates can be used to adjust the forecasts based on the observed changes in the data due to COVID-19. For example, you can include a covariate that captures the effect of lockdowns or travel restrictions on tourism data. Scenario Analysis Conduct scenario analysis to explore the potential impact of different COVID-19 scenarios on your forecasts. By considering a range of possible outcomes, you can better prepare for the uncertainties associated with the pandemic. Sensitivity Analysis Evaluate the sensitivity of your forecasts to changes in key assumptions or parameters. By conducting sensitivity analysis, you can identify the factors that have the greatest impact on your forecasts and assess the robustness of your models.

#### Data Integration

The Oxford COVID-19 Government Response Tracker (OxCGRT) provides valuable data on government responses to the COVID-19 pandemic, including a Stringency Index that quantifies the severity of lockdown measures. Let me provide more details about this index:

*Stringency Index:* The Stringency Index is a composite measure that evaluates the strictness of government policies related to COVID-19. It calculates a score based on nine key response metrics: - School closures - Workplace closures - Cancellation of public events - Restrictions on public gatherings - Closures of public transport - Stay-at-home requirements - Public information campaigns - Restrictions on internal movements - International travel controls Each metric is assigned a value between 0 and 100, with a higher score indicating a stricter response. The overall Stringency Index is the mean score of these nine metrics. If policies vary at the subnational level, the index reflects the strictest sub-region's response level. Importantly, the Stringency Index records the strictness of government policies but does not measure or imply the appropriateness or effectiveness of a country's response. A higher score does not necessarily mean that a country's response is better than others lower on the index.

source - [Our World In Data](https://datacatalog.med.nyu.edu/dataset/10394)

Here you can observe the stringency index for the Philippines and Switzerland :
```{r}
# Convert data to a time series object
tourism_ts <- tourism_data_zurich_philippines
#rename Date as date
names(tourism_ts)[names(tourism_ts) == "Date"] <- "date"
  
#read .csv with stringency index
stringency_df <- read.csv(here("data/stringency_index.csv"))

# Filter data by location
stringency_philippines <- filter(stringency_df, location == "Philippines")
stringency_switzerland <- filter(stringency_df, location == "Switzerland")

# Convert dates and set them to the first day of the month
stringency_philippines$date <- as.Date(format(dmy(stringency_philippines$date), "%Y-%m-01"))
stringency_switzerland$date <- as.Date(format(dmy(stringency_switzerland$date), "%Y-%m-01"))

# Aggregate to monthly average, ensuring date format is maintained
stringency_philippines <- stringency_philippines %>%
  group_by(date) %>%
  summarize(avg_stringency_index = mean(stringency_index, na.rm = TRUE))

stringency_switzerland <- stringency_switzerland %>%
  group_by(date) %>%
  summarize(avg_stringency_index = mean(stringency_index, na.rm = TRUE))

# Merge with Philippines data first
merged_data_philippines <- merge(tourism_ts, stringency_philippines, by = "date", all.x = TRUE)

# Then merge with Switzerland data
merged_data <- merge(merged_data_philippines, stringency_switzerland, by = "date", all.x = TRUE, suffixes = c("_PH", "_SW"))

# Replace NA values in avg_stringency_index with 0 if necessary
merged_data$avg_stringency_index_PH[is.na(merged_data$avg_stringency_index_PH)] <- 0
merged_data$avg_stringency_index_SW[is.na(merged_data$avg_stringency_index_SW)] <- 0


# Create a ggplot of the stringency index
ggplot(merged_data, aes(x = date, y = avg_stringency_index_PH, color = "Philippines")) +
  geom_line() +
  geom_line(aes(y = avg_stringency_index_SW, color = "Switzerland")) +
  labs(title = "Stringency Index in the Philippines and Switzerland",
       x = "Date",
       y = "Stringency Index") +
  scale_color_manual(values = c("#3C5B6F", "darkred"),
                     labels = c("Philippines", "Switzerland"))
```
We see that Philippines had a higher stringency index than Switzerland. 

You can observe here the resulted data from the merge of the stringency index and the tourism data :
```{r}
#show merge data using reactable
reactable(merged_data)
```

#### Finding a Model

Choose a forecasting model that can incorporate exogenous variables (covariates).

#####  Multiple Regression Analysis

Simple yet effective, if the relationships between the covariates and the dependent variable (tourist numbers) are linear.

Here is a summary of the effect of the variables on the number of tourists from the Philippines to Zurich :
```{r}
# Fit a multiple regression model
model <- lm(value ~ avg_stringency_index_PH + avg_stringency_index_SW, data = merged_data)

# Summary of the model
summary(model)

# Forecast the next 24 months
forecast_values <- predict(model, newdata = merged_data)

#us gtsummary to show the summary of the model
model %>%
  gtsummary::tbl_regression()
```

We observe that the p-value are lower for Switzerland than for Philippines. This means that government stringency index in Switzerland has a more significant impact on the number of tourists than in the Philippines. Indeed, the beta of -12 for Switzerland and 5.9 for Philippines shows that the number of tourists in Switzerland decreases by 12 for each unit of stringency index, which seems logical. However the number of tourists in the Philippines increases by 5.9 for each unit of stringency index, which is counter-intuitive. This could be due to the fact that the stringency index is not the only factor that influences the number of tourists from the Philippines to Zurich. 

We can observe here the metrics:
```{r}
#create a table with the metrics of the model and show it as an html
model_metrics <- model %>%
  broom::glance()

# show html table with metrics
model_metrics %>%
  kable("html", caption = "Model Metrics") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

BLABLABLA explain metrics
The way higher AIC shows that this model is not the best.

##### ARIMAX 

We try here to integrate the stringency index as an exogenous variable in the ARIMA model. This will allow us to account for the impact of COVID-19 on the number of tourists from the Philippines to Zurich.

We fix seasonality as TRUE and stepwise and approximation as FALSE to have a more thorough search for the best model, as we saw before this provided better results.

```{r}
# Transform to a time series object with frequency 12 (monthly data)
tourism_ts <- ts(merged_data$value, frequency = 12, start = c(2005, 1))  # Adjust the start time as per your data

# Ensure exogenous variables have the same length and frequency
exog_data <- cbind(merged_data$avg_stringency_index_PH, merged_data$avg_stringency_index_SW)

# Check if lengths of tourism_ts and exog_data match
if (length(tourism_ts) == nrow(exog_data)) {
  # Fit an ARIMAX model
  model <- auto.arima(tourism_ts, xreg = exog_data, seasonal = TRUE, stepwise = FALSE, approximation = FALSE)
  
  # Summary of the model
  summary(model)
  
  # Forecast the next 15 months, setting future exogenous variables to 0
  future_exog <- matrix(0, nrow = 15, ncol = 2)
  
  forecast_values <- forecast(model, xreg = future_exog, h = 24)
  
  # Convert the forecast to a data frame
  forecast_arimax <- as.data.frame(forecast_values)
  
  # Rename the columns for clarity
  colnames(forecast_arimax) <- c("Point Forecast", "Lo 80", "Hi 80",
                                 "Lo 95", "Hi 95")
  forecast_arimax$Date <- seq(as.Date("2023-10-01"), by = "month",
                              length.out = 15)
  # Plot the forecast along with the actual data using autoplot from the forecast package
  plot_forecast <- autoplot(forecast_values, series = "Forecast") +
    autolayer(tourism_ts, series = "Actual Data") +
    labs(title = "ARIMAX Forecast of Tourists from the Philippines to Zurich",
         x = "Date",
         y = "Number of Tourists") +
    guides(colour = guide_legend(title = "Data Type"))
  
  plot_forecast
    # Calculate evaluation metrics on the training data
  residuals <- residuals(model)
  mae <- mean(abs(residuals))
  mape <- mean(abs(residuals / tourism_ts)) * 100
  rmse <- sqrt(mean(residuals^2))
  aic <- AIC(model)
  bic <- BIC(model)
  
  # Print evaluation metrics
  cat("Evaluation Metrics:\n")
  cat("MAE:", mae, "\n")
  cat("MAPE:", mape, "\n")
  cat("RMSE:", rmse, "\n")
  cat("AIC:", aic, "\n")
  cat("BIC:", bic, "\n")
} else {
  stop("Length of tourism_ts and exog_data do not match. Please check the data.")
}
```

Here are the metrics of the ARIMAX model with the metrics of the ARIMA model for comparison :
```{r}
#show metric in html
model_metrics <- data.frame(
  Model = "ARIMAX",
  MAE = mae,
  MAPE = mape,
  RMSE = rmse,
  AIC = aic,
  BIC = bic
)

#show html table with metrics
metrics_arimax <- model_metrics %>%
  kable("html", caption = "Model Metrics") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
metrics_arimax
metrics_arima_table
```

Summary
Best in MAE and MAPE: ARIMAX
Best in RMSE: ARIMA_auto_stepwise
Best in AIC: ARIMA_auto_stepwise
Overall, ARIMA_auto_stepwise shows the best balance in terms of RMSE and AIC, while ARIMAX excels in MAE and MAPE. Depending on which metric is prioritized, either ARIMAX or ARIMA_auto_stepwise would be the preferred model.

#### Other ideas

A Ddeveloper, pq on a pas choisi, bblabla, ...
- Dummy variable for the covid period. We could have a dummy variable that takes the value 1 during the covid period and 0 otherwise. This would allow the model to adjust the forecasts to reflect the changes in the data due to COVID-19.
-   Replacing covid values with the ARIMA, If the missing values are random or if excluding them would result in a loss of valuable information, we might consider imputing them. One common approach is to use statistical models like ARIMA to interpolate missing values based on the patterns observed in the available data.
-   Delete the timestamp of the covid period and use fill_gaps() to fill the missing values and then use the a model to predict the missing values.


# Model Selection
## Vaud
Implement model selection metrics comparison,blabla and logic behind it

## Zurich and Philippines
To reformulate !!
Use Information Criteria for Model Comparison: Evaluate models based on criteria such as RMSE, MAE, MAPE, AIC (Akaike Information Criterion) or BIC (Bayesian Information Criterion), which help in selecting a model that balances goodness of fit with complexity.

```{r}
metrics_naive
metrics_ets
metrics_arima_table
metrics_arimax
```

Based on the comparison of the metrics:

- ETS_M_seaso_Ad stands out with the lowest MAE (48.9) and RMSE (74.7), making it the most accurate model in terms of absolute and square error metrics. However, its MAPE (105) is not as low as the ARIMAX model's MAPE (74.9).
- ARIMAX has a competitive AIC (2744) and a lower MAPE (74.9) compared to the ETS models, but a higher MAE (65) and RMSE (105) than ETS_M_seaso_Ad.

Given that the primary goal is to predict the number of visitors accurately:

- ETS_M_seaso_Ad is recommended because it has the lowest MAE and RMSE, indicating more precise predictions, which are crucial for ensuring accurate and actionable insights for decision-making in Zurich's tourism sector.
- Although the ARIMAX model has a competitive AIC and a reasonable MAPE, its MAE and RMSE are not as competitive as the ETS_M_seaso_Ad model.

Using both forecast hand in hand could be a better approach to have a more robust forecast than selecting only one model.

Here are the forecasted values for the two models :
```{r}
# Assuming forecast_arimax and forecast_ETS_M_seaso_Ad are already available

# Rename the columns for clarity
colnames(forecast_arimax) <- c("ARIMAX_Forecast", "ARIMAX_Lo_80", "ARIMAX_Hi_80", "ARIMAX_Lo_95", "ARIMAX_Hi_95", "Date")

# Convert the 'Date' column to Date type for merging
forecast_arimax$Date <- as.Date(forecast_arimax$Date)

# Extract the relevant columns from forecast_ETS_M_seaso_Ad
forecast_ETS_M_seaso_Ad <- forecast_ETS_M_seaso_Ad %>%
  select(Date = index, ETS_M_seaso_Ad_Forecast = .mean)

# Convert the 'Date' column to Date type for merging
forecast_ETS_M_seaso_Ad$Date <- as.Date(paste(forecast_ETS_M_seaso_Ad$Date, "01", sep = "-"), format = "%Y %b-%d")

# Merge the two data frames based on the Date
combined_forecast <- merge(forecast_arimax, forecast_ETS_M_seaso_Ad, by = "Date")

# Calculate the delta between the two forecasts
combined_forecast <- combined_forecast %>%
  mutate(Delta = ETS_M_seaso_Ad_Forecast - ARIMAX_Forecast)

# Remove the unnecessary columns
combined_forecast <- combined_forecast %>%
  select(Date, ARIMAX_Forecast, ETS_M_seaso_Ad_Forecast, Delta)

# Display the combined table using reactable
reactable(
  combined_forecast,
  columns = list(
    Date = colDef(name = "Date"),
    ARIMAX_Forecast = colDef(
      name = "ARIMAX Forecast",
      format = colFormat(digits = 2)
    ),
    ETS_M_seaso_Ad_Forecast = colDef(
      name = "ETS_M_seaso_Ad Forecast",
      format = colFormat(digits = 2)
    ),
    Delta = colDef(
      name = "Delta",
      format = colFormat(digits = 2)
    )
  ),
  defaultPageSize = 5,
  highlight = TRUE,
  striped = TRUE,
  bordered = TRUE,
  filterable = TRUE,
  searchable = TRUE,
  sortable = TRUE,
  resizable = TRUE
)
```

# Appendix

## General Overview
As the dataset provided is in German, we have translated the data in English to make it more intuitive and understandable for everyone. Then, we created a new 'Date' column, year-month-day, which corresponds to the correct format to be able to make predictions.

Here are the first 1000 instances of the raw data :

```{r Tourism ALL}
#show data using reactable only showing the first 100 rows
reactable(head(tourism_data_no_total, 1000), 
          searchable = TRUE,
          defaultPageSize = 5,
          sortable = TRUE,
          filterable = TRUE,
          pagination = TRUE,
          bordered = TRUE,
          highlight = TRUE,
          striped = TRUE,
          compact = TRUE,
          showPageSizeOptions = TRUE,
          showSortable = TRUE
          )
```

## Tourism Data - Zurich

We filtered the "Kanton" column to keep only the canton of Zurich.

Here are the first 1000 instances of the raw data :

```{r Tourism Zurich}
#show the data in a table using reactable
reactable(head(tourism_data_zurich, 1000), 
          searchable = TRUE,
          defaultPageSize = 5,
          sortable = TRUE,
          filterable = TRUE,
          pagination = TRUE,
          bordered = TRUE,
          highlight = TRUE,
          striped = TRUE,
          compact = TRUE,
          showPageSizeOptions = TRUE,
          showSortable = TRUE
          )
```

There are 1869 missing values for the two sub-datasets. These missing values come from the 'value' column, creating gaps in the time series. We'll see later how we're going to process them to do modelling.

## Zurich and All visiting countries

The graph shows the monthly number of overnight stays in Zurich from tourists of different countries.

```{r}
# Preparing the data
#removing value in column 'Herkunftsland' as it is just the whole of Switzerland
data <- tourism_data_zurich %>%
  filter(!is.na(value)) %>%  # Removing rows with NA values in the 'value' column
  mutate(Monat = month(Date, label = TRUE, abbr = TRUE),  # Extract month 
         Jahr = year(Date)) %>%  # Extract year from Date
  group_by(Herkunftsland, Date) %>%  # Group by country and date
  summarise(Trips = sum(value), .groups = 'drop')  # Summing up trips for each country per date

p <- ggplot(data, aes(x = Date, y = Trips, group = Herkunftsland,
                      color = Herkunftsland == "Philippinen",
                      text = paste("Country:", Herkunftsland, "<br>Trips:", Trips))) +  # Added text for tooltip
  geom_line(show.legend = FALSE) +
    scale_color_viridis_d() +  # Use viridis color palette
  labs(title = "Number of Trips from Each Country to Zurich",
       x = "Date",
       y = "Number of Trips") +
  theme_minimal()

# Convert to an interactive plotly object
interactive_plot <- ggplotly(p, tooltip = "text", width = 600, height = 600)

# Adjust plotly settings 
interactive_plot <- interactive_plot %>%
  layout(
    margin = list(l = 60, r = 60, b = 60, t = 80),  # Adjust margins
    showlegend = FALSE  # Show legend
  )

# Display the interactive plot
interactive_plot
```

## Additive STL
The additive time series decomposition of the monthly overnight stays for tourists coming from the Philippines to the canton of Zurich shows:

```{r Decomposition-zh}
# Convert data to a time series object
tourism_ts <- tourism_data_zurich_philippines %>%
  arrange(Date) %>%
  # Ensure data is complete and monthly
  complete(Date = seq.Date(min(Date), max(Date), by = "month")) %>%
  replace_na(list(value = 0)) %>%  # Replace NA values if there are any
  # Create a time series object
  with(ts(value, frequency = 12, start = decimal_date(min(Date))))

# Decompose the time series
decomposed <- decompose(tourism_ts, type = 'multiplicative')

# Plot the decomposed components
decomposed

# Perform STL decomposition
stl(tourism_ts, s.window = "periodic") %>% 
  autoplot() +
  labs(x = "Date", y = "Number of tourists", title = "STL Decomposition for number of tourists from Philippines to Zurich") +
  theme_minimal()
```

## Seasonality ZH

Seasonal sub-series plot permit to better visualize the monthly fluctuations of each year, from 2005 to 2023.

```{r}
# Plot the seasonality in one chart
ggseasonplot(tourism_ts, year.labels = TRUE, year.labels.left = TRUE) +
  scale_color_viridis_d() +
  theme_minimal()
```

We clearly observe here that the seasonality is not constant over time.